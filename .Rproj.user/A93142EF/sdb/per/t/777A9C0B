{
    "collab_server" : "",
    "contents" : "generate_opti_probe_list <- function(genomes){\n  \n  percent_vec <- numeric()\n  count_vec <- numeric()\n  columns = c(\"C|G\", \"N\", \"Index\", \"Contig\", \"lig\", \"1st_half\", \"2nd_half\", \"tf\", \"Freq_1st_half\", \"ASF\")\n  kmers_optimal_allasf <- data.frame(matrix(vector(), 0, length(columns),\n                                     dimnames=list(c(), columns)),\n                                     stringsAsFactors=F)\n  \n  for(j in 1:length(genomes)){\n    genome <- genomes[j]\n    \n    ### Read in Genome ###\n    ASF_member <- readDNAStringSet(genome)\n    \n    ### Chop Genome up into 40 bp kmers ###\n    view.width <- 40\n    letters <- c(\"CG\",\"N\")\n    columns = c(\"C|G\", \"N\", \"Index\", \"Contig\")\n    kmers_40bp_ID_C_all <- data.frame(matrix(vector(), 0, 4,\n                                      dimnames=list(c(), columns)),\n                                      stringsAsFactors=F)\n    n <- length(ASF_member)\n    for (i in 1:n){\n      kmers_40bp <- letterFrequencyInSlidingView(ASF_member[[i]], view.width, letters, as.prob=T)\n      a <- seq_len(nrow(kmers_40bp))\n      kmers_40bp_ID <- cbind(kmers_40bp, Index=a)\n      kmers_40bp_ID_C <- cbind(kmers_40bp_ID, Contig=i)\n      kmers_40bp_ID_C_all <- rbind(kmers_40bp_ID_C_all, kmers_40bp_ID_C)\n      rm(kmers_40bp, a, kmers_40bp_ID)\n    }\n    \n    ### Delete Kmers comtaining at least one 'N'###\n    kmers_40bp_noN <- filter(kmers_40bp_ID_C_all, N == 0)\n    \n    ### Isolate probes with -AA- in middle for optimal ligation ###\n    n = length(ASF_member)\n    lig_site <- DNAStringSet()\n    kmer20a   <- DNAStringSet()\n    kmer20b   <- DNAStringSet()\n    for (i in 1:n){\n      kmers_40bp_noN_ci <- filter(kmers_40bp_noN, Contig == i)\n      range <- IRanges(start = kmers_40bp_noN_ci$Index+19, end = kmers_40bp_noN_ci$Index+20)\n      range2 <- IRanges(start = kmers_40bp_noN_ci$Index, end = kmers_40bp_noN_ci$Index+19)\n      range3 <- IRanges(start = kmers_40bp_noN_ci$Index+20, end = kmers_40bp_noN_ci$Index+39)\n      lig_site <- append(lig_site, extractAt(ASF_member[[i]], range))\n      kmer20a <- append(kmer20a, extractAt(ASF_member[[i]], range2))\n      kmer20b <- append(kmer20b, extractAt(ASF_member[[i]], range3))\n    }\n    kmers <- cbind(kmers_40bp_noN, lig = lig_site, `1st_half` = kmer20a, `2nd_half` = kmer20b)\n    \n    ### Filter kmers based on optimal ligation probe ###\n    tf <- kmers$lig == 'AA'\n    kmers_lig_tf <- cbind(kmers, tf)\n    \n    ### Filter kmers based on GC content being identical in 40bp kmer and 20bp kmers. ###\n    letters <- c(\"CG\")\n    freq <- letterFrequency(kmer20a, letters, as.prob=TRUE)\n    colnames(freq) <- c(\"Freq_1st_half\")\n    kmers_lig_tf_freq <- cbind(kmers_lig_tf, freq)\n    \n    # Apply halves GC frequency and ligation probe center filters\n    kmers_opti_lig <- filter(kmers_lig_tf_freq, `tf`== TRUE)\n    kmers_optimal <- filter(kmers_opti_lig, kmers_opti_lig$Freq_1st_half == kmers_opti_lig$`C|G`)\n    asf_name_vec <- rep(genome, nrow(kmers_optimal))\n    kmers_optimal_asf <- cbind(kmers_optimal, ASF = asf_name_vec)\n    \n    ### Return two values of interest: the percent with the max probes and how many probes there are in that group. ###\n    kmers_gc_range <- filter(kmers_optimal_asf, `C|G` >= 0.35 & `C|G` <= 0.65)\n    freq <- as.data.frame(table(unlist(kmers_gc_range$`C|G`)))\n    gc_opti <- filter(freq, freq$Freq == max(freq$Freq))\n\n    if (j == 1) {\n      count_matrix <- matrix(ncol=length(genomes),nrow=nrow(freq))\n      rownames(count_matrix) <- freq$Var1\n      colnames(count_matrix) <- genomes\n    }\n    ### Create data frames of important info to keep with each revolution in loop ###\n    count_matrix[,j] <- c(freq$Freq)\n    kmers_optimal_allasf <- rbind(kmers_optimal_allasf, kmers_gc_range)\n    sprintf(\"Genome %g: done\", j)\n  }\n  \n  all_probe_options <- count_matrix\n  min_vec <- apply(count_matrix,1,min)\n  Opti_GC <- as.numeric(levels(gc_opti$Var1))[which.max(min_vec)]\n  c <- filter(kmers_optimal_allasf, `C|G` == Opti_GC)\n  \n  ### Add global alignment scores to dataframe to limit the chance of hairpin formation and homo-dimerization\n  score <- pairwiseAlignment(DNAStringSet(c$`1st_half`), reverseComplement(DNAStringSet(c$`2nd_half`)), type = \"global\", scoreOnly = TRUE)\n  kmers_optimal_allasf_opti <- cbind(c, score)\n  \n  return(list(Opti_GC, all_probe_options, kmers_optimal_allasf_opti))\n}\n\n###\n# https://www.idtdna.com/pages/decoded/decoded-articles/ask-alex/ask-alex/2012/04/11/how-can-i-determine-if-a-hairpin-in-my-oligo-is-too-strong-to-allow-hybridization-\n# Using free OligoAnalyzer® software, part of the IDT SciTools programs, enter your oligonucleotide sequence\n# and choose “Hairpin.” The software will generate a series of possible hairpin structures. You can arrange \n# these structures in order of decreasing melting temperature (Tm). If the highest hairpin Tm is at or above \n# your annealing temperature, that hairpin is likely to impede hybridization.\n###\n\n### Create histogram of kmer GC content ###\n# ggplot(data=kmers_opti_lig, aes(kmers_opti_lig$`C|G`)) + geom_histogram(breaks=seq(0, 1, by = 0.005))\n# mean(kmers_opti_lig$`C|G`)\n# sd(kmers_opti_lig$`C|G`)\n# unique(kmers_opti_lig$`C|G`)\n\n### Make a bunch of variables ###\n# x <- as.list(rnorm(10))\n# names(x) <- paste(\"a\", 1:length(x), sep = \"\")\n# list2env(x , envir = .GlobalEnv)\n\n\n",
    "created" : 1502809207198.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1943950461",
    "id" : "777A9C0B",
    "lastKnownWriteTime" : 1501623048,
    "last_content_update" : 1501623048,
    "path" : "C:/Users/Moutinho/Google Drive/Luminex Project/Luminex_R_Code/generate_opti_probe_list.R",
    "project_path" : "generate_opti_probe_list.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
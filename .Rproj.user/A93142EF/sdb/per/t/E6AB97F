{
    "collab_server" : "",
    "contents" : "# Call Genomes to Identify Ideal Probe Sites\n# Thomas J Moutinho Jr, July 2017\n\n### QUESTIONS FOR PAUL ###\n# Is there a better way to clean the RAM that was previously used after removing a variable? I've used gc(), \n#   but that doesn't seem to get everything. \n\n# Are there any noticable parts of this that could be done faster? \n\n# When I align the optimal probes to all of the genomes, I don't remove the regions of the genomes that have \n#   N's (instead of A,T,G, or C). I reason that it is better to keep those regions because when we allow mismatches\n#   the probes will be able to match in those regions if there is sufficient alignment. What do you think? \n\n### Clear Global Environment ###\nrm(list=ls())\ngc()\n\n### Load Libraries ###\nlibrary(Biostrings) #Need Bioconductor Package\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tictoc)\nlibrary(parallel)\n\n### Load Functions ###\nsource(\"generate_opti_probe_list.R\") ## Edit the name of the column for the genome file names.\nsource(\"return_multi_vars.R\")\nsource(\"match_probes.R\")\n\n### Run function to find the optimal probes ###\ngenome_fastas <- c(\"ASF356.fna\", \"ASF360.fna\", \"ASF361.fna\", \"ASF457.fna\", \n                   \"ASF492.fna\", \"ASF500.fna\", \"ASF502.fna\", \"ASF519.fna\")\n# tic()\nc(opti_percent_gc, probe_counts, opti_probes) := generate_opti_probe_list(genome_fastas) # 21 seconds per genome\n# toc()\n\n### Get top x number of probes for each member ###\ntop_num = 11 ## This number sets how many probes for each species are tested for alignment (with mismatches) to the rest of the genomes.\n\ncolumns = c()\nn = length(top_num*length(genome_fastas))\ntop_of_each <- data.frame(matrix(vector(), n, 0,\n                           dimnames=list(c(), columns)),\n                           stringsAsFactors=F)\nfor(i in 1:length(genome_fastas)){\n  df <- head(opti_probes,top_num)\n  one_mem <- filter(opti_probes, opti_probes$ASF == genome_fastas[i])\n  one_mem_order <- one_mem[order(one_mem$score, decreasing = FALSE),] %>% head(top_num)\n  top_of_each <- rbind(top_of_each, one_mem_order)\n}\n\n### Parallelized code to check how many mismatches each probe can have without aligning to genomic DNA ###\nmismatch_num = 10 ## 25% of the probe can be mismatched. \nprobe_or_no_set <- vector(mode = \"numeric\", nrow(top_of_each));\nunique_to_self_set <- vector(mode = \"numeric\", nrow(top_of_each));\n\nfor(k in 1:length(genome_fastas)){\n  tic()\n  ### Make a DNAStringSet of the fragments to feed into vcountPattern ###\n  fragments <- DNAStringSet()\n  range <- (1+(top_num*(k-1))):((top_num*(k-1))+top_num)\n  for(n in range){\n    i <- match(top_of_each$ASF[n], genome_fastas)\n    j <- top_of_each$Contig[n]\n    range <- IRanges(start = top_of_each$Index[n], end = top_of_each$Index[n]+39)\n    genomes <- sapply(genome_fastas, readDNAStringSet)\n    fragment <- extractAt(genomes[[i]][[j]], range)\n    fragments <- append(fragments, fragment)\n  }\n  ### Check for uniqueness in own genome ###\n  genome <- readDNAStringSet(genome_fastas[k])\n  n = length(genome)\n  genome_seq_set <- DNAStringSet()  \n  for (i in 1:n){\n    df_contig_member <- filter(top_of_each, top_of_each$ASF == genome_fastas[k], top_of_each$Contig == i)\n    df_contig_member_ordered <- df_contig_member[order(df_contig_member$Index),]\n    set_of_index_vals <- df_contig_member_ordered$Index\n    if(length(set_of_index_vals) > 0){\n      index_ranges <- vector(mode = \"numeric\")\n      for(w in 1:length(set_of_index_vals)){\n        index_set <- (set_of_index_vals[w]-mismatch_num):(set_of_index_vals[w]+39+mismatch_num)\n        index_ranges <- append(index_ranges, index_set)\n      }\n      index_full <- 1:(length(genome[[i]])-39)\n      index <- index_full[-c(index_ranges)]\n      range  <- IRanges(start = index, end = index+39)\n      genome_seq_set <- append(genome_seq_set, extractAt(genome[[i]], range))\n    }\n    else if(length(set_of_index_vals) == 0){\n      index <- 1:(length(genome[[i]])-39)\n      range  <- IRanges(start = index, end = index+39)\n      genome_seq_set <- append(genome_seq_set, extractAt(genome[[i]], range))\n    }\n  }\n  sequence_set_one <- genome_seq_set # This set of sequences is from one member of the set, but without the sequences that are where the optimal probes will match to. \n  \n  ### Create a genome set to assay the probes against ###\n  genomes <- sapply(genome_fastas[-k], readDNAStringSet)\n  n = length(genomes)\n  genomic_seq_set <- DNAStringSet()  \n  for (i in 1:n){\n    m = length(genomes[[i]])\n    for (j in 1:m){\n      index <- 1:(length(genomes[[i]][[j]])-39)\n      range  <- IRanges(start = index, end = index+39)\n      genomic_seq_set <- append(genomic_seq_set, extractAt(genomes[[i]][[j]], range))\n    }\n  }\n  sequence_set <- genomic_seq_set # This set of sequences does not contain data from one member of the set. \n  \n  ### Parallel Code ###\n  no_cores <- 4 #detectCores()/4\n  clust <- makeCluster(no_cores)\n  eval <- clusterEvalQ(clust, {source(\"match_probes.R\")\n                               library(Biostrings)\n                               library(tictoc)})\n  clusterExport(clust, c(\"sequence_set\", \"sequence_set_one\",\"mismatch_num\"))\n  range <- (1+(top_num*(k-1))):((top_num*(k-1))+top_num)\n  probe_or_no_set[range] <- parSapply(clust, fragments, function(x) match_probes(x, sequence_set, mismatch_num))\n  unique_to_self_set[range] <- parSapply(clust, fragments, function(x) match_probes(x, sequence_set_one, mismatch_num))\n  stopCluster(clust)\n  toc()\n  gc()\n}\ntop_of_each_mm_uts <- cbind(top_of_each, probe_or_no_set, unique_to_self_set)\n\nprobe_options_all_data <- filter(top_of_each_mm_uts, top_of_each_mm_uts$probe_or_no_set == 1, top_of_each_mm_uts$unique_to_self_set == 1)\nPROBE_OPTIONS <- probe_options_all_data[ , c(\"C|G\",\"Index\",\"Contig\",\"1st_half\",\"2nd_half\",\"ASF\")]\n\n### Print results to Excel file ###\nlibrary(xlsx)\nwrite.xlsx2(PROBE_OPTIONS, \"PROBE_OPTIONS.xlsx\")\n\n",
    "created" : 1502809197998.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "733257945",
    "id" : "E6AB97F",
    "lastKnownWriteTime" : 1501863749,
    "last_content_update" : 1501863749,
    "path" : "C:/Users/Moutinho/Google Drive/Luminex Project/Luminex_R_Code/Filter_for_ideal_probes.R",
    "project_path" : "Filter_for_ideal_probes.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}